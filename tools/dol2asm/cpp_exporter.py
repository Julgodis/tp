import os
import sys
import re
import subprocess
from pathlib import Path
from collections import defaultdict
from builder import Builder

import disassembler as dasm
from capstone import *
from capstone.ppc import *
from symbols import *

def export_symbol_header(builder: Builder, section: SectionPart, symbol: Symbol):
    assert symbol.name.name
    assert symbol.name.label
    builder.write("/* %08X %04X %-10s %-60s */" % (symbol.addr, symbol.size, section.name, symbol.name.name))

def disassemble_cpp_callback(address, offset, insn, bytes, builder):
    # Output label (if any)
    if address in dasm.labels:
        builder.write("%s:" % dasm.addr_to_label(address))
    prefixComment = '/* %08X %08X  %02X %02X %02X %02X */' % (
        address, offset, bytes[0], bytes[1], bytes[2], bytes[3])
    asm = None
    raw = dasm.read_u32(offset)
    if insn != None:
        asm = dasm.insn_to_text(address, insn, raw, False)
    else:  # Capstone couldn't disassemble it
        idx = (raw & 0xfc000000) >> 26
        idx2 = (raw & 0x000007fe) >> 1
        # mtspr
        if idx == 31 and idx2 == 467:
            asm = dasm.disasm_mspr(raw, 1)
        # mfspr
        elif idx == 31 and idx2 == 339:
            asm = dasm.disasm_mspr(raw, 0)
        # mcrxr
        elif idx == 31 and idx2 == 512:
            asm = dasm.disasm_mcrxr(raw)
        # fcmpo
        elif idx == 63 and idx2 == 32:
            asm = dasm.disasm_fcmp(raw)
        # Paired singles
        elif idx == 4:
            asm = dasm.disasm_ps(raw)
        elif idx in {56, 57, 60, 61}:
            asm = dasm.disasm_ps_mem(raw, idx)
    if asm == None:
        asm = '.4byte 0x%08X  /* unknown instruction */' % raw
    builder.write('%s\t%s' % (prefixComment, asm))

def export_symbol_function(builder: Builder, section: SectionPart, function: Function):
    label = function.name.mwcc_label
    file_label = label
    if len(file_label) > 240:
        file_label = "func_%08X" % function.addr
    path = section.tu.getFilePath("_include/", "/")
    include_path = "%s%s.s" % (path, file_label)
    util.mkdir(include_path)
    print("\t\t%s" % include_path)

    builder.write("// TODO: DEMANGLED NAME")
    builder.write("asm void %s() {" % label)
    builder.write("\tnofralloc")
    builder.write("#include \"%s\"" % include_path)
    builder.write("}")
    builder.write("")

    for block in function.blocks:
        dasm.add_label(block.addr, block.name.mwcc_label)

    include_builder = Builder(include_path, builder.DRY_RUN, [])
    for block in function.blocks:
        dasm.disasm(block.data, block.addr, block.size, disassemble_cpp_callback, include_builder)
    include_builder.close()

def export_symbol_vtable_data(builder: Builder, section: SectionPart, vtable: VTableData):
    builder.write("const void* %s[%i] = {" % (vtable.name.mwcc_label, len(vtable.table)))
    for symbol in vtable.table:
        if not symbol:
            builder.write("\tNULL,")
        else:
            builder.write("\t(void*)%s," % symbol.name.mwcc_label)
    builder.write("};")

def export_symbol(builder: Builder, section: SectionPart, symbol: Symbol):
    if builder.DRY_RUN:
        return

    export_symbol_header(builder, section, symbol)

    if isinstance(symbol, Function):
        export_symbol_function(builder, section, symbol)
    elif isinstance(symbol, VTableData):
        export_symbol_vtable_data(builder, section, symbol)
    elif isinstance(symbol, InitializedData):
        pass #export_symbol_init_data(builder, section, symbol)
    elif isinstance(symbol, ReadOnlyData):
        pass #export_symbol_readonly_data(builder, section, symbol)
    else:
        print("warning: cannot export unknown symbol type '%s'" % (type(symbol).__name__))


def export_section_preprocess(section: SectionPart, labels):
    for symbol in section.symbols:
        labels.update(symbol.getInternalReferences())

def export_section(builder: Builder, section: SectionPart):
    builder.write("")
    builder.write("/* ###################################################################################### */")
    builder.write("/* %s */" % section.export_name.center(86))
    builder.write("/* ###################################################################################### */")
    builder.write("#pragma section \"%s\"" % section.export_name)
    builder.write("")


    for symbol in section.symbols:
        export_symbol(builder, section, symbol)


def export_translation_unit(BASEROM, DRY_RUN, tu: TranslationUnit, symbol_map):
    filepath = tu.getFilePath("cpp/", ".cpp")
    util.mkdir(filepath)
    print("\t%s" % filepath)

    builder = Builder(filepath, DRY_RUN, BASEROM)
    builder.write("// ")
    builder.write("// Generated By: dol2asm")
    builder.write("// ")
    builder.write("")

    labels = set()
    for section in tu.section_parts:
        export_section_preprocess(section, labels)

    builder.write("// ")
    builder.write("// Additional Symbols:")
    builder.write("// ")
    builder.write("")
    builder.write("extern \"C\" {")
    sorted_labels = list(labels)
    sorted_labels.sort()
    for addr in sorted_labels:
        if addr in symbol_map:
            symbol = symbol_map[addr]
            if isinstance(symbol, Function):
                builder.write("extern void %s();" % symbol.name.mwcc_label)
            else:
                builder.write("extern int %s;" % symbol.name.mwcc_label)

    builder.write("}")
    builder.write("")

    for section in tu.section_parts:
        export_section(builder, section)

    builder.close()


def export_library(BASEROM, DRY_RUN, library: Library, symbol_map):
    path = library.getPath("cpp/")

    print("[C++] Exporting", path)
    for tu in library.translation_units:
        export_translation_unit(BASEROM, DRY_RUN, tu, symbol_map)

def export_all(BASEROM, DRY_RUN, libraries, symbol_map):
    for library in libraries:
        export_library(BASEROM, DRY_RUN, library, symbol_map)
