//
// Generated By: dol2asm
// Translation Unit: JKRDvdFile
//

#include "JSystem/JKernel/JKRDvdFile.h"
#include "dol2asm.h"
#include "dolphin/dvd/dvdfs.h"
#include "dolphin/types.h"

struct JUTException {
    /* 802E21FC */ static void panic_f(char const*, int, char const*, ...);
};

/* 8043436C-80434378 06108C 000C+00 4/4 0/0 0/0 .bss             sDvdList__10JKRDvdFile */
JSUList<JKRDvdFile> JKRDvdFile::sDvdList;

/* 802D9584-802D95F8 2D3EC4 0074+00 0/0 3/3 0/0 .text            __ct__10JKRDvdFileFv */
JKRDvdFile::JKRDvdFile() : JKRFile(), mDvdLink(this) {
    initiate();
}

/* 802D95F8-802D96A0 2D3F38 00A8+00 0/0 2/2 0/0 .text            __ct__10JKRDvdFileFPCc */
JKRDvdFile::JKRDvdFile(const char* fileName) : JKRFile(), mDvdLink(this) {
    initiate();
    mIsAvailable = open(fileName);
    // CODE: not matching without this _weird_ pointless branch
    if (mIsAvailable)
        return;
}

/* 802D96A0-802D9748 2D3FE0 00A8+00 0/0 3/3 0/0 .text            __ct__10JKRDvdFileFl */
JKRDvdFile::JKRDvdFile(s32 entryNum) : JKRFile(), mDvdLink(this) {
    initiate();
    mIsAvailable = open(entryNum);
    // CODE: not matching without this _weird_ pointless branch
    if (mIsAvailable)
        return;
}

/* 802D9748-802D97E4 2D4088 009C+00 1/0 5/5 0/0 .text            __dt__10JKRDvdFileFv */
JKRDvdFile::~JKRDvdFile() {
    close();
}

/* 802D97E4-802D9850 2D4124 006C+00 3/3 0/0 0/0 .text            initiate__10JKRDvdFileFv */
void JKRDvdFile::initiate() {
    mDvdFile = this;
    OSInitMutex(&mReadMutex);
    OSInitMutex(&mMutex2);
    OSInitMessageQueue(&mResultMessageQueue, &mResultMessage, 1);
    OSInitMessageQueue(&mMessageQueue1, &mMessage1, 1);
    mReadMainThreadRecord = NULL;
    field_0x50 = 0;
    field_0x58 = 0;
}

/* 802D9850-802D98C4 2D4190 0074+00 1/0 1/1 0/0 .text            open__10JKRDvdFileFPCc */
bool JKRDvdFile::open(char const* fileName) {
    if (!mIsAvailable) {
        mIsAvailable = DVDOpen(fileName, &mFileInfo);
        if (mIsAvailable) {
            getDvdList().append(&mDvdLink);
            getStatus();  // CODE: query DVD status using mFileInfo
        }
    }
    return mIsAvailable;
}

/* 802D98C4-802D9938 2D4204 0074+00 1/0 2/2 0/0 .text            open__10JKRDvdFileFl */
bool JKRDvdFile::open(s32 entryNum) {
    if (!mIsAvailable) {
        mIsAvailable = DVDFastOpen(entryNum, &mFileInfo);
        if (mIsAvailable) {
            getDvdList().append(&mDvdLink);
            getStatus();  // CODE: query DVD status using mFileInfo
        }
    }
    return mIsAvailable;
}

/* 802D9938-802D99B4 2D4278 007C+00 1/0 0/0 0/0 .text            close__10JKRDvdFileFv */
void JKRDvdFile::close() {
    if (mIsAvailable) {
        s32 result = DVDClose(&mFileInfo);
        if (result != 0) {
            mIsAvailable = false;
            getDvdList().remove(&mDvdLink);
        } else {
            JUTException::panic_f("JKRDvdFile.cpp", 0xd5, "%s", "cannot close DVD file\n");
        }
    }
}

/* 802D99B4-802D9A68 2D42F4 00B4+00 1/0 0/0 0/0 .text            readData__10JKRDvdFileFPvll */
s32 JKRDvdFile::readData(void* data, s32 length, s32 offset) {
    OSLockMutex(&mReadMutex);

    // NOTE: reading from the same file using multiple threads is not supported
    if (mReadMainThreadRecord) {
        OSUnlockMutex(&mReadMutex);
        return -1;
    }

    mReadMainThreadRecord = OSGetCurrentThread();

    s32 result = -1;
    if (DVDReadAsyncPrio(&mFileInfo, data, length, offset, JKRDvdFile::doneProcess,
                         DVD_PRIORITY_DEFAULT)) {
        result = sync();
    }

    mReadMainThreadRecord = NULL;
    OSUnlockMutex(&mReadMutex);

    return result;
}

/* 802D9A68-802D9A70 2D43A8 0008+00 1/0 0/0 0/0 .text            writeData__10JKRDvdFileFPCvll */
s32 JKRDvdFile::writeData(void const* data, s32 length, s32 offset) {
    return -1;
}

/* 802D9A70-802D9AC4 2D43B0 0054+00 1/1 0/0 0/0 .text            sync__10JKRDvdFileFv */
s32 JKRDvdFile::sync() {
    OSLockMutex(&mReadMutex);

    OSMessage message;
    OSReceiveMessage(&mResultMessageQueue, &message, 1);

    mReadMainThreadRecord = NULL;
    OSUnlockMutex(&mReadMutex);

    // NOTE: the 'message' is the same as 'result' paramater from JKRDvdFile::doneProcess.
    return (s32)message;
}

/* 802D9AC4-802D9AF8 2D4404 0034+00 1/1 0/0 0/0 .text doneProcess__10JKRDvdFileFlP11DVDFileInfo */
void JKRDvdFile::doneProcess(s32 result, DVDFileInfo* fileInfo) {
    // CODE: get the JKRDvdFile member mDvdFile by accessing it after the fileInfo (mFileInfo).
    JKRDvdFile* dvdFile = *(JKRDvdFile**)(fileInfo + 1);
    OSSendMessage(&dvdFile->mResultMessageQueue, (OSMessage)result, OS_MESSAGE_NON_BLOCKING);
}

/* 802D9AF8-802D9B00 2D4438 0008+00 1/0 0/0 0/0 .text            getFileSize__10JKRDvdFileCFv */
s32 JKRDvdFile::getFileSize() const {
    return DVDGetLength(&mFileInfo);
}
